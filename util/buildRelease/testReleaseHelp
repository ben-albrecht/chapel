#!/bin/bash

#
# unset normal Chapel environment variables
#
unset CHPL_HOME
unset CHPL_NIGHTLY_LOGDIR
unset CHPL_DEVELOPER
unset CHPL_HOST_PLATFORM
unset CHPL_TARGET_PLATFORM
unset CHPLDEVTMP

# Directory of script, will not work if script is a symlink
DIR=$(cd "$(dirname "${filepath}")" && pwd)

# Shallow test to see if we are in the correct directory
# Just probe to see if we have a few essential subdirectories --
# indicating that we are probably in a Chapel root directory.
chpl_home=$( cd $DIR/../../ && pwd )
if [ ! -d "$chpl_home/util" ] || [ ! -d "$chpl_home/compiler" ] || [ ! -d "$chpl_home/runtime" ] || [ ! -d "$chpl_home/modules" ]; then
    # Chapel home is assumed to be one directory up from setenvchpl.bash script
    echo "Error: \$CHPL_HOME is not where it is expected"
    return 1
fi

# Number of logical processes on current system. Will be used as number of jobs
# when calling make with parallel execution.
num_procs=$(${DIR}/chpl-make-cpu_count)

#
# execute actions specified in README
#
if [ $# -eq 0 ]; then
    echo "usage: $argv[0] <make utility>"
    exit 1
fi
source util/quickstart/setchplenv.bash
tmpstatus=$status
if [ $tmpstatus != 0 ]; then
    echo "ERROR: source of setchplenv.bash failed"
    exit $tmpstatus
fi
$mymake -j$num_procs
set tmpstatus = $status
if ($tmpstatus != 0); then
    echo "ERROR: make failed"
    exit $tmpstatus
fi
rehash   # required for csh only; if we convert this to bash, drop this
set tmpstatus = $status
if ($tmpstatus != 0); then
    echo "ERROR: make failed"
    exit $tmpstatus
fi
$mymake check
set tmpstatus = $status
if ($tmpstatus != 0); then
    echo "ERROR: make check failed"
    exit $tmpstatus
fi
chpl -o hello examples/hello.chpl
set tmpstatus = $status
if ($tmpstatus != 0); then
    echo "ERROR: compilation of hello.chpl failed"
    exit $tmpstatus
fi
./hello
set tmpstatus = $status
if ($tmpstatus != 0); then
    echo "ERROR: execution of hello failed"
    exit $tmpstatus
fi

# Build chpldoc and run chpldoc-check.
$mymake -j$num_procs chpldoc
set tmpstatus = $status
if ($tmpstatus != 0); then
    echo "ERROR: make chpldoc failed"
    exit $tmpstatus
fi
rehash   # required for csh only; if we convert this to bash, drop this

$mymake check-chpldoc
set tmpstatus = $status
if ($tmpstatus != 0); then
    echo "ERROR: make check-chpldoc failed"
    exit $tmpstatus
fi


# Calculate expected version string from version_num.h.
set major=`cat compiler/main/version_num.h | grep MAJOR_VERSION | cut -f3 -d' ' | sed 's/\"//g'`
set minor=`cat compiler/main/version_num.h | grep MINOR_VERSION | cut -f3 -d' ' | sed 's/\"//g'`
set patch=`cat compiler/main/version_num.h | grep UPDATE_VERSION | cut -f3 -d' ' | sed 's/\"//g'`
set expected_version_string="$major.$minor.$patch"

# Test chpl --version for expected string version.
set version_string = `chpl --version | grep 'version' | cut -d' ' -f 3`
set versionstatus = $status
if ($versionstatus != 0); then
    echo "ERROR: execution of chpl --version failed"
    exit $versionstatus
fi
if ($version_string != "$expected_version_string"); then
    echo "ERROR: unexpected version string, received '$version_string' expected '$expected_version_string'"
    exit 1
fi

#
# run make in examples directory
#
cd examples
$mymake -j$num_procs
set tmpstatus = $status
if ($tmpstatus != 0); then
    echo "ERROR: compiling examples with 'make' failed"
    exit $tmpstatus
fi
cd ..


#
# run test system on examples directory
#
cd examples
set tmpstatus = $status
if ($tmpstatus != 0); then
    echo "ERROR: cd into examples failed"
    exit $tmpstatus
fi

set start_test_flags = ''
if ($?CHPL_TEST_RELEASE_NORECURSE); then
    set start_test_flags = ${start_test_flags}' --norecurse'
fi

./start_test ${start_test_flags} -logfile Logs/testReleaseHelp.log

fi
set tmpstatus = $status
if ($tmpstatus != 0); then
    echo "ERROR: testing of examples failed"
    exit $tmpstatus
fi

exit 0
